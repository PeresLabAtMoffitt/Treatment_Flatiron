---
title: "Flatiron data cleaning and analysis report"
author: "Christelle Colin-Leitzinger"
date: '`r Sys.Date()`'
output: 
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: false
    theme: flatly
    highlight: pygments
    df_print: paged
---

<style type="text/css">
.figure {
   margin-top: 25px;
   <!-- margin-bottom: 100px; -->
}

table {
    margin-top: 25px;
    <!-- margin-bottom: 100px !important; -->
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning = FALSE,
                      message = FALSE,
                      cache = FALSE,
                      fig.align='center'
                      )
options(gtsummary.print_engine = "gt")
options(gtsummary.as_gt.addl_cmds = "gt::tab_options(table.font.size = 14, data_row.padding = gt::px(1))")
```

# Data cleaning
***
<br>

```{r library, include=FALSE}
library(drake)
library(tidyverse)
library(data.table)
library(lubridate)
library(ggplot2)
library(gtsummary)
library(survminer)
library(survival)
```

```{r loadd}
loadd(clinical_data, vitals, drugs, auc, creatinine)
```

## Creatinine cleaning

Only creatinine from blood and serum are being used. All units are correct (mg/dL).  
Here an sample of the non-cleaned data with really low `testresultcleaned`.

```{r creatinine, rows.print=15, max.print=15}
creatinine %>% filter(str_detect(labcomponent, "blood|serum")) %>% 
arrange(testresultcleaned)
```
All `testresultcleaned` and `testresult` variable are cleaned as :  
-creat < 0.8 is set at 0.8  
-creat > 3 are eliminated  
To create the final `creatinine` variable ,`testresultcleaned` and `testresult` are both used but `testresultcleaned` is used over `testresult` when both are available.

Here a sample of the cleaned data
```{r creatinine1, rows.print=15, max.print=15}
creatinine <- creatinine %>%
  # remove creatine urine
  filter(str_detect(labcomponent, "blood|serum")) %>% 
  mutate(creatinine = case_when(
    testresultcleaned < 0.8        ~ 0.8,
    testresultcleaned > 3          ~ NA_real_,
    TRUE                           ~ testresultcleaned
  )) %>% 
  # F092F8B827DDC kept umol/L as they actually are mg/dL range 45 to 90 Î¼mol/L (0.5 to 1.0 mg/dL) for women.
  mutate(creatinine1 = case_when(
    testresult < 0.8               ~ 0.8,
    testresult > 3                 ~ NA_real_,
    TRUE                           ~ testresult
  )) %>% 
  mutate(creatinine = coalesce(creatinine, creatinine1)) %>% 
  filter(!is.na(creatinine)) %>% 
  mutate(testdate = as.Date(testdate, format = "%m/%d/%y")) %>% 
  select(c("patientid", creat_date = "testdate", "creatinine", creat_units = "testunitscleaned"))
creatinine %>% distinct(patientid, .keep_all = TRUE)

vitals <- vitals %>% 
  mutate(testdate = as.Date(testdate, format = "%m/%d/%y"))
body_surface_area <- vitals %>% 
  filter(labcomponent == "Body Surface Area (BSA)")
```
<br>

## Body surface area cleaning

`testresultcleaned` is all within expected range but only few data is available (`r NROW(body_surface_area %>% filter(!is.na(testresultcleaned)) %>% distinct(patientid, .keep.all=TRUE))` patients). Even less with an associated date!   

```{r bsa}
body_surface_area
```

By using `testresult` and before cleaning only `r NROW(body_surface_area %>% filter(!is.na(body_surface_area$testresult)) %>% distinct(patientid, .keep.all=TRUE))` patients have data for their BSA. So I will also use the height and weight of patients to calculate their BSA by using the Du Bois formula.  

To create the final `BSA` variable ,`testresultcleaned` is used over `testresult` when both are available.  
`testresult` was further cleaned as data < 0.418 and > 4.14 are eliminated. These values were calculated from the biggest and the smallest individuals recorded.  
I also remove the outliers within patient (2 examples here).

```{r}
vitals %>% 
  filter(labcomponent == "Body Surface Area (BSA)" & patientid == "F2D5A8748B268") %>% 
  select(patientid, testdate, testresult, testresultcleaned)
vitals %>% 
  filter(labcomponent == "Body Surface Area (BSA)" & patientid == "F875EA1B044F0") %>% 
  select(patientid, testdate, testresult, testresultcleaned)
# F3AE4546B5D12
```

Here a sample of the cleaned data

```{r bsa1, rows.print=15, max.print=15}
body_surface_area <- vitals %>% 
  filter(labcomponent == "Body Surface Area (BSA)") %>% # only 399 patients data
  # Limit max = 4.14, min = 0.418 calculated for biggest to smallest person
  mutate(testresult = ifelse(testresult < 0.418 | testresult > 4.14, NA_real_, testresult)) %>% 
  group_by(patientid) %>%
  # I used the median to remove outlier within a patient
  mutate(median_testresult = median(testresult)) %>% 
  ungroup() %>% 
  mutate(BSA = case_when(
    testresult > (median_testresult + 0.4) |
      testresult < (median_testresult - 0.4)      ~ NA_real_,
    TRUE                                          ~ testresult
  )) %>% 
  mutate(BSA = coalesce(testresultcleaned, BSA)) %>% 
  filter(!is.na(BSA)) %>% 
  mutate(BSA_units = "m2") %>% 
  select(c("patientid", bsa_date = "testdate", "BSA", "BSA_units"))

body_surface_area %>% distinct(patientid, .keep_all = TRUE)
```
<br>

## Height

Height data complicated. Again you have `testresultcleaned` and `testresult` with `testresultcleaned` which will prioritized.  
`testresultcleaned` has units in cm but some data are wrong. `testresult` has results in cm, ft or in. It is pretty easy to clean data between these 3 units because the measurement cannot overlap.
Both are cleaned as < 120 or > 231 are eliminated. These value are for the shortest and tallest women recorded.
The units can be filled by patients when absent.

```{r height}
vitals %>% 
  filter(test == "body height" & patientid == "FCB6DAAFF6527")
# FC109A6F719E7
# FC106805F9AB9
# F91590CB83EC8 weird
```

Outliers are eliminated as much as possible.

```{r height1}
vitals %>% 
  filter(test == "body height") %>% 
  # To get more data, I have data from testresult that can be used
  # But need to fill up testunits, transfer in kg and coalesce.
  group_by(patientid) %>% 
  fill(testunits, .direction = "downup") %>% # F004D683A1695 have testresult, F615C37BF1470 is wrong, Otherwise I checked them all to see we can do that
  ungroup() %>% 
  # Clean up outliers compare to tallest ans smallest record
  mutate(testresultcleaned = case_when(
    testresultcleaned > 231 | # Tallest women height
      testresultcleaned < 120 # Average height dwarf = 122 cm, 4 feet, I take 120 by loooking at the data
                                     ~ NA_real_,
    TRUE                             ~ testresultcleaned
  )) %>% 
  mutate(testresult = case_when(
    testresult > 231 & testunits == "cm" |
      testresult < 100 & testunits == "cm" |
      testresult > 7.58 & testunits == "ft" |
      testresult < 3.28 & testunits == "ft" |
      testresult > 90.94 & testunits == "in" |
      testresult < 39.37 & testunits == "in"|
      testresult == 0
                                     ~ NA_real_,
    TRUE                             ~ testresult
  )) %>% 
  # Clean up outliers within patient by using the median for each patients/unit. Eliminate the ones with too much variation.
  group_by(patientid) %>%
  mutate(median_testresultcleaned = median(testresultcleaned)) %>% 
  ungroup() %>% 
  mutate(testresultcleaned_verified = case_when(
    testresultcleaned > (median_testresultcleaned + 5) | # choose 5 cm by default
      testresultcleaned < (median_testresultcleaned - 5)      ~ NA_real_, # F01413C06D921 weird
    TRUE                                                      ~ testresultcleaned
  )) %>% 
  filter(patientid == "F01413C06D921") %>% 
  select(c("patientid", testdate, testresultcleaned, median_testresultcleaned, testresultcleaned_verified,
           testunitscleaned, testunits, testresult))
```

PB: Some patient don't have dates but have data. Should I take a mean of all the height measured or the first one - If I have to choose I would take the mean (patients shouldn't grow or shorten much)?
If all dates are NA for a patients, I cannot combined `height` with `episodedate` of the drug data.

Here a samples of the data.
```{r height2, rows.print=15, max.print=15}
height <- vitals %>% 
  filter(test == "body height") %>% 
  # To get more data, I have data from testresult that can be used
  # But need to fill up testunits, transfer in kg and coalesce.
  group_by(patientid) %>% 
  fill(testunits, .direction = "downup") %>% # F004D683A1695 have testresult, F615C37BF1470 is wrong, Otherwise I checked them all to see we can do that
  ungroup() %>% 
  # Clean up outliers compare to tallest ans smallest record
  mutate(testresultcleaned = case_when(
    testresultcleaned > 231 | # Tallest women height
      testresultcleaned < 120 # Average height dwarf = 122 cm, 4 feet, I take 120 by loooking at the data
                                     ~ NA_real_,
    TRUE                             ~ testresultcleaned
  )) %>% 
  mutate(testresult = case_when(
    testresult > 231 & testunits == "cm" |
      testresult < 100 & testunits == "cm" |
      testresult > 7.58 & testunits == "ft" |
      testresult < 3.28 & testunits == "ft" |
      testresult > 90.94 & testunits == "in" |
      testresult < 39.37 & testunits == "in"|
      testresult == 0
                                     ~ NA_real_,
    TRUE                             ~ testresult
  )) %>% 
  # Clean up outliers within patient by using the median for each patients/unit. Eliminate the ones with too much variation.
  group_by(patientid) %>%
  mutate(median_testresultcleaned = median(testresultcleaned)) %>% 
  ungroup() %>% 
  mutate(testresultcleaned_verified = case_when(
    testresultcleaned > (median_testresultcleaned + 5) | # choose 5 cm by default
      testresultcleaned < (median_testresultcleaned - 5)      ~ NA_real_, # F01413C06D921 weird
    TRUE                                                      ~ testresultcleaned
  )) %>% 
  # select(c("patientid", testdate, testresultcleaned, median_testresultcleaned, testresultcleaned_verified, 
  #          testunitscleaned, testunits, testresult)) %>% 
  
  group_by(patientid, testunits) %>%
  mutate(median_testresult = median(testresult)) %>% 
  ungroup() %>% 
  mutate(testresult_verified = case_when(
    testresult > (median_testresult + 3) & 
      testunits == "in" |
      testresult < (median_testresult - 3) & 
      testunits == "in"                         ~ NA_real_,
    testresult > (median_testresult + 5) & 
      testunits == "cm" |
      testresult < (median_testresult - 5) & 
      testunits == "cm"                         ~ NA_real_,
    TRUE                                        ~ testresult
  )) %>% 
  # select(c("patientid", testdate, testresult, median_testresult, testresult_verified,
  #          testunits, testunitscleaned, testresultcleaned, testresultcleaned_verified))
  
  mutate(height = case_when(
    !is.na(testresultcleaned_verified)          ~ round(testresultcleaned_verified / 100, 3), # cm to m
    testunits == "cm"                           ~ round(testresult_verified / 100, 3),
    testunits == "ft"                           ~ round(testresult_verified / 3.281, 3), # ft to m
    testunits == "in" | 
      !is.na(testresult)                        ~ round(testresult_verified / 39.37, 3) # in to m
    )) %>% 
  filter(!is.na(height)) %>% 
  mutate(height_units = "m") %>% 
  select(c("patientid", height_date = "testdate", "height", "height_units"))

height %>% distinct(patientid, .keep_all = TRUE)
```
`r emo::ji("check")`

<br>

## Weight

The more complex cleaning (before the drugs...`r emo::ji("sad")`). Contrary to height with units which don't overlap. Weight has data in `kg` in `testresultcleaned` and `kg`, `lb`, `oz` in `testresult`which are overlapping (a person can be 150lbs or 150kg).  
Cleanup of `testresultcleaned`...  
```{r}
vitals %>%
  filter(test == "body weight") %>% 
  select(c("patientid", "testdate", "testunits", "testresult", "testunitscleaned", "testresultcleaned")) %>%
  # 1.Clean testresultcleaned
  group_by(patientid) %>%
  mutate(median_testresultcleaned = median(testresultcleaned, na.rm = TRUE)) %>% 
  ungroup() %>%
  mutate(weight1 = case_when(
    testresultcleaned >= 27 &       # Biggest recorded 291.6 kg (642.9 lbs, 10286 oz)
      testresultcleaned < 292 &     # lightest 5.5 kg (12 lbs, 194 oz)  F0027D3926C88
      (testresultcleaned > (median_testresultcleaned - 39.6) & # F1493F8F5A924, F54F47F4419E0, F18E68D19D10F
         testresultcleaned < (median_testresultcleaned + 39.6))     ~ testresultcleaned, 
    TRUE ~ NA_real_
  )) %>% filter(patientid == "F0027D3926C88")
```
... and eliminate the outliers (36.4 kg can be normal for FF5268589DBE2, 39.5 F54F47F4419E0) 37.7 not F4A3B1B659865, F6CA354D599AA.
I have an idea on how to improve that better `r emo::ji("cross_mark")``r emo::ji("light_bulb")``r emo::ji("bookmark")`
```{r}
vitals %>%
  filter(test == "body weight") %>% 
  select(c("patientid", "testdate", "testunits", "testresult", "testunitscleaned", "testresultcleaned")) %>%
  # 1.Clean testresultcleaned
  group_by(patientid) %>%
  mutate(median_testresultcleaned = median(testresultcleaned, na.rm = TRUE)) %>% 
  ungroup() %>%
  mutate(weight1 = case_when(
    testresultcleaned >= 27 &       # Biggest recorded 291.6 kg (642.9 lbs, 10286 oz)
      testresultcleaned < 292 &     # lightest 5.5 kg (12 lbs, 194 oz)  F0027D3926C88
      (testresultcleaned > (median_testresultcleaned - 39.6) & # F1493F8F5A924, F54F47F4419E0, F18E68D19D10F
         testresultcleaned < (median_testresultcleaned + 39.6))     ~ testresultcleaned, 
    TRUE ~ NA_real_
  )) %>% filter(str_detect(patientid, "F6CA354D599AA|F4A3B1B659865|FF5268589DBE2|F93CEAE4BF764|F1493F8F5A924|F18E68D19D10F|F54F47F4419E0"))
```


Cleanup of `testresult` for each units separately because can have 2 units per patients which can be correct or not.
Plus try to rescue the units when some are `NA` but not all and eliminate the outliers.
```{r}
vitals %>%
  filter(test == "body weight") %>% 
  select(c("patientid", "testdate", "testunits", "testresult", "testunitscleaned", "testresultcleaned")) %>%
  # 1.Clean testresultcleaned
  group_by(patientid) %>%
  mutate(median_testresultcleaned = median(testresultcleaned, na.rm = TRUE)) %>% 
  ungroup() %>%
  mutate(weight1 = case_when(
    testresultcleaned >= 27 &       # Biggest recorded 291.6 kg (642.9 lbs, 10286 oz)
      testresultcleaned < 292 &     # lightest 5.5 kg (12 lbs, 194 oz)  F0027D3926C88
      (testresultcleaned > (median_testresultcleaned - 39.6) & # F1493F8F5A924, F54F47F4419E0, F18E68D19D10F
         testresultcleaned < (median_testresultcleaned + 39.6))     ~ testresultcleaned, 
    TRUE ~ NA_real_
  )) %>% 
  # mutate(difference = (median_testresultcleaned)-testresultcleaned) # Can improve by > 30 and > 10 from previous measure so need to create a gap var ---------
  # 2.Clean testresult to be used to find max and min
  mutate(testresult = case_when(
    testunits == "lb" &
      testresult > 12 &
      testresult < 643            ~ testresult,
    testunits == "kg" &
      testresult >= 5.5 &
      testresult < 292            ~ testresult,
    testunits == "oz" &
      testresult > 194 &
      testresult < 10286          ~ testresult,
    is.na(testunits) & 
    testresult > 5.5 & 
      testresult < 10286          ~ testresult, # combine oz, kg, lbs for when units is NA
    TRUE                          ~ NA_real_
  )) %>% filter(str_detect(patientid, "F0027D3926C88"))

weight <- vitals %>%
  filter(test == "body weight") %>% 
  select(c("patientid", "testdate", "testunits", "testresult", "testunitscleaned", "testresultcleaned")) %>%
  # 1.Clean testresultcleaned
  group_by(patientid) %>%
  mutate(median_testresultcleaned = median(testresultcleaned, na.rm = TRUE)) %>% 
  ungroup() %>%
  mutate(weight1 = case_when(
    testresultcleaned >= 27 &       # Biggest recorded 291.6 kg (642.9 lbs, 10286 oz)
      testresultcleaned < 292 &     # lightest 5.5 kg (12 lbs, 194 oz)  F0027D3926C88
      (testresultcleaned > (median_testresultcleaned - 39.6) & # F1493F8F5A924, F54F47F4419E0, F18E68D19D10F
         testresultcleaned < (median_testresultcleaned + 39.6))     ~ testresultcleaned, 
    TRUE ~ NA_real_
  )) %>% 
  # mutate(difference = (median_testresultcleaned)-testresultcleaned) # Can improve by > 30 and > 10 from previous measure so need to create a gap var ---------
  # 2.Clean testresult to be used to find max and min
  mutate(testresult = case_when(
    testunits == "lb" &
      testresult > 12 &
      testresult < 643            ~ testresult,
    testunits == "kg" &
      testresult >= 5.5 &
      testresult < 292            ~ testresult,
    testunits == "oz" &
      testresult > 194 &
      testresult < 10286          ~ testresult,
    is.na(testunits) & 
    testresult > 5.5 & 
      testresult < 10286          ~ testresult, # combine oz, kg, lbs for when units is NA
    TRUE                          ~ NA_real_
  ))
```
```{r}
weight %>% 
  # 3. Calculate median for each units and remove data outside range for each patients/unit
  # 3. help distinguishing lbs to kg for same patient when unit is NA
  group_by(patientid, testunits) %>%
  mutate(median_testresult = median(testresult, na.rm = TRUE)) %>% 
  ungroup() %>% 
  mutate(testresult_verified = case_when(       # Can improve by > 30 and > 10 from previous measure so need to create a gap var --------
    testunits == "kg" &
    (testresult > (median_testresult + 38.5) | # choose 38.5 cm by default could do 32 if not for F534F9C4FF968
       # 12 F2F31607FD6AD , FA7C8143AEE58 gain 37kg, F847A533FAE7E gain 38, FBE6E66AB2C95 gain 41, FC09E942CB0D7 gain 49
       # F5B18C17A28F5 and F98077E9119EC FA53D0F672C7D FCFF0EDFE278F, FEF3273967DB3 wrong in cleaned too
      testresult < (median_testresult - 38.5))         ~ NA_real_, 
    testunits == "lb" &
      (testresult > (median_testresult + 99) | # choose 99 cm by default, # Problem when wrong first value FCC755E4F8722 (94.8) keep in case close to first dosinf
         testresult < (median_testresult - 99))      ~ NA_real_, # 91 for F00C16FEE3F74
    TRUE                                             ~ testresult
  )) %>% filter(str_detect(patientid, "FEF3273967DB3|F181950A26A19|F14EBD0D0FA81|F4A3B1B659865"))

weight1 <- weight %>% 
  # 3. Calculate median for each units and remove data outside range for each patients/unit
  # 3. help distinguishing lbs to kg for same patient when unit is NA
  group_by(patientid, testunits) %>%
  mutate(median_testresult = median(testresult, na.rm = TRUE)) %>% 
  ungroup() %>% 
  mutate(testresult_verified = case_when(       # Can improve by > 30 and > 10 from previous measure so need to create a gap var --------
    testunits == "kg" &
    (testresult > (median_testresult + 38.5) | # choose 38.5 cm by default could do 32 if not for F534F9C4FF968
       # 12 F2F31607FD6AD , FA7C8143AEE58 gain 37kg, F847A533FAE7E gain 38, FBE6E66AB2C95 gain 41, FC09E942CB0D7 gain 49
       # F5B18C17A28F5 and F98077E9119EC FA53D0F672C7D FCFF0EDFE278F, FEF3273967DB3 wrong in cleaned too
      testresult < (median_testresult - 38.5))         ~ NA_real_, 
    testunits == "lb" &
      (testresult > (median_testresult + 99) | # choose 99 cm by default, # Problem when wrong first value FCC755E4F8722 (94.8) keep in case close to first dosinf
         testresult < (median_testresult - 99))      ~ NA_real_, # 91 for F00C16FEE3F74
    TRUE                                             ~ testresult
  )) %>%  # FCC755E4F8722 keep the first value anyway, eliminate that F8CB4CAB1073A (has 96 lbs difference-median) ?
  # mutate(cal = testresult-median_testresult)
  # mutate(difference = (median_testresultcleaned)-testresultcleaned)

  # 4. Rescue testunits when testresult_verified is close 
  # Calculate max and min to limit value for each patient-Choose 20
  group_by(patientid, testunits) %>%
  mutate(max_kg = case_when(
    testunits == "kg" ~ max(testresult_verified, na.rm = TRUE) + 20 # F181950A26A19
  )) %>%
  mutate(min_kg = case_when(
    testunits == "kg" ~ min(testresult_verified, na.rm = TRUE) - 20
  )) %>%
  mutate(max_lbs = case_when(
    testunits == "lb" ~ max(testresult_verified, na.rm = TRUE) + 30 # F14EBD0D0FA81
  )) %>%
  mutate(min_lbs = case_when(
    testunits == "lb" ~ min(testresult_verified, na.rm = TRUE) - 30
  )) %>%
  ungroup() %>% 
  group_by(patientid) %>% 
  fill(max_kg, min_kg, max_lbs, min_lbs, .direction = "downup") %>% # min_kg, max_lbs
  ungroup() %>%
  
  mutate(testunits_rescue = case_when(
    is.na(testunits) &
      testresult_verified < max_kg        ~ "kg", # Good doesn't work with F16847515CAF4 , Perfect for F8A3DD629CDA6
    is.na(testunits) & # FE8DBCAC6DAFB
      testresult_verified > min_lbs      ~ "lb" # F004D683A1695, F10CAD0F4EC48, FC109A6F719E7, FD25ED170CF07, FE06FF7C3E108, F044601199C5D
  ))
weight1 %>% filter(str_detect(patientid, "FEF3273967DB3|F181950A26A19|F14EBD0D0FA81|F4A3B1B659865"))
```

Sometimes `testunits` is wrong or change so try to rescue the unit within the same patient.
Rescue units for when value is twice a `kg` value, it is `lb` value. 
```{r}
weight2 <- weight1 %>% 
  group_by(patientid) %>% 
  # 5. Rescue testunits when testresult_verified is twice or /2 means that lb or kg 
  # if is 2 times the weight in kg add lb F14EBD0D0FA81
  mutate(testunits_rescue1 = case_when(
    is.na(testunits) &
      testresult_verified < (max_kg * 2.205) &
      testresult_verified > (min_kg * 2.205)         ~ "lb",
    is.na(testunits) &
      testresult_verified < (max_lbs / 2.205) &
      testresult_verified > (min_lbs / 2.205)        ~ "kg"
  )) %>% 
  ungroup() %>% 
  mutate(testunits = coalesce(testunits, testunits_rescue, testunits_rescue1)) %>% 
  select(c("patientid", "testdate", "testunits", "testresult", "testresult_verified", "testunitscleaned", "testresultcleaned", "weight1"))
weight1 %>% filter(str_detect(patientid, "F14EBD0D0FA81|F534F9C4FF968"))
weight2 %>% filter(str_detect(patientid, "F14EBD0D0FA81|F534F9C4FF968"))
```


Can finally recalculate weight.

F0027D3926C88
```{r}
weight <- weight2 %>% 
  # 6.Fill up weight with new testresult_verified cleaned
  mutate(weight2 = case_when(
    is.na(testresultcleaned) &
      testunits == "kg"         ~ testresult_verified, # F0027D3926C88, FE8DBCAC6DAFB, F8A3DD629CDA6, F020C6A8B9E50, F16847515CAF4
    is.na(testresultcleaned) & # F044601199C5D
      testunits == "lb"         ~ (testresult_verified / 2.205), # FCB918617347C, F5E3D88009911, F14EBD0D0FA81, F16847515CAF4, FABC474931881
  )) %>% 
  mutate(weight = coalesce(weight1, weight2)) %>% 
  filter(!is.na(weight)) %>% 
  mutate(weight_units = "kg") %>% 
  select(c("patientid", weight_date = "testdate", "weight", "weight_units"))
weight
```

## AUC

I selected only AUC collected for the taxel and platin drugs but can have really high and low number.
```{r}
auc %>% 
  filter(str_detect(drugname, "taxel|platin")) %>% 
  filter(!is.na(relativeorderedamount)) %>% arrange(relativeorderedamount)
auc %>% 
  filter(str_detect(drugname, "taxel|platin")) %>% 
  filter(!is.na(relativeorderedamount)) %>% arrange(desc(relativeorderedamount))
```
I clean the data up by keeping the `relativeorderedamount`:  
- >= 50 & <= 175 for taxel  and with a unit in `mg/m2`  
- >= 2  & <= 6   for platin and with a unit in `AUC`
But few example for taxel
```{r}
auc %>% 
  filter(str_detect(drugname, "taxel|platin")) %>% 
  filter(!is.na(relativeorderedamount)) %>% 
  # select(c("patientid", "expectedstartdate", orderedamount, orderedunits, "relativeorderedamount",
  #          "relativeorderedunits", "drugname", iscanceled)) %>%
  mutate(target_auc = case_when( # F7D7377578248 what for the patients who have order amount
    # relativeorderedunits == "mg/kg" |
    #   relativeorderedunits == "mg" |
    #   relativeorderedunits == "m"         ~ NA_real_,
    str_detect(drugname, "taxel") &
      relativeorderedunits == "mg/m2" &
      relativeorderedamount >= 50 &
      relativeorderedamount <= 175        ~ relativeorderedamount, # F21904E0D872F we should open more? F11B625154B62
    str_detect(drugname, "platin") &
      relativeorderedunits == "AUC" &
      relativeorderedamount >= 2 &
      relativeorderedamount <= 6          ~ relativeorderedamount, # F4E8C8717878B, FE3FF3A5AC465, F853DC24CD5E8
    TRUE                                  ~ NA_real_
  )) %>% filter(str_detect(patientid, "F21904E0D872F|F11B625154B62"))
```

But few example for platin
```{r}
auc %>% 
  filter(str_detect(drugname, "taxel|platin")) %>% 
  filter(!is.na(relativeorderedamount)) %>% 
  # select(c("patientid", "expectedstartdate", orderedamount, orderedunits, "relativeorderedamount",
  #          "relativeorderedunits", "drugname", iscanceled)) %>%
  mutate(target_auc = case_when( # F7D7377578248 what for the patients who have order amount
    # relativeorderedunits == "mg/kg" |
    #   relativeorderedunits == "mg" |
    #   relativeorderedunits == "m"         ~ NA_real_,
    str_detect(drugname, "taxel") &
      relativeorderedunits == "mg/m2" &
      relativeorderedamount >= 50 &
      relativeorderedamount <= 175        ~ relativeorderedamount, # F21904E0D872F we should open more? F11B625154B62
    str_detect(drugname, "platin") &
      relativeorderedunits == "AUC" &
      relativeorderedamount >= 2 &
      relativeorderedamount <= 6          ~ relativeorderedamount, # F4E8C8717878B, FE3FF3A5AC465, F853DC24CD5E8
    TRUE                                  ~ NA_real_
  )) %>% filter(str_detect(patientid, "F4E8C8717878B|FE3FF3A5AC465|F853DC24CD5E8"))
```

Also we will see later that a lot of patients don't have any AUC. We talked and you advice to use the formula but I think that if we take the dose that a patient receive to reverse calculate the AUC we will automatically bias our results as we will create a AUC witch fit to the dose they received. Let me know if I misunderstood!!
The result data
```{r AUC}
areaUC <- auc %>% 
  filter(str_detect(drugname, "taxel|platin")) %>% 
  filter(!is.na(relativeorderedamount)) %>% 
  # select(c("patientid", "expectedstartdate", orderedamount, orderedunits, "relativeorderedamount",
  #          "relativeorderedunits", "drugname", iscanceled)) %>%
  mutate(target_auc = case_when( # F7D7377578248 what for the patients who have order amount
    # relativeorderedunits == "mg/kg" |
    #   relativeorderedunits == "mg" |
    #   relativeorderedunits == "m"         ~ NA_real_,
    str_detect(drugname, "taxel") &
      relativeorderedunits == "mg/m2" &
      relativeorderedamount >= 50 &
      relativeorderedamount <= 175        ~ relativeorderedamount, # F21904E0D872F we should open more? F11B625154B62
    str_detect(drugname, "platin") &
      relativeorderedunits == "AUC" &
      relativeorderedamount >= 2 &
      relativeorderedamount <= 6          ~ relativeorderedamount, # F4E8C8717878B, FE3FF3A5AC465, F853DC24CD5E8
    TRUE                                  ~ NA_real_
  )) %>%
  select(c("patientid", auc_date = "expectedstartdate", "target_auc", 
           auc_units = "relativeorderedunits", "drugname")) %>% 
  filter(!is.na(target_auc))
areaUC
```

## Clinical
```{r}
clinical_data
```

I cleaned up `race` as I think we want `Hispanic` to be in the `White` category. I aslo calculate `aprox_month_at_os` with `diagnosisdate` and `followupdate` (not complete date).
```{r}
clinical_data <- clinical_data %>% 
  mutate(race = case_when(
    str_detect(race, "Black")    ~ "Black",
    str_detect(race, "Hispanic") ~ "White",
    TRUE                         ~ race
  )) %>% 
  mutate(ethnicity = (str_remove(ethnicity, " or Latino"))) %>% 
  unite(raceeth1, c(race,ethnicity), sep = " ", remove = FALSE, na.rm = TRUE) %>% 
  mutate(vital = case_when(
    vitalstatus == 0     ~ "Alive",
    vitalstatus == 1     ~ "Dead"
  )) %>% 
  mutate(aprox_month_at_os = interval(start = diagnosisdate, end = followupdate)/
           duration(n=1, units = "months")) %>% 
  mutate(stagecat = na_if(stagecat, "Unk Stage")) %>% 
  mutate(across(.cols = c(histology, groupstage, tstage), ~na_if(., "Unknown/not documented")))
clinical_data
```


## Drugs

`r emo::ji("face_screaming_in_fear")` 

```{r}

```





`r  emo::ji("party_popper")`





